---
title: 18. 散列表
---

散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，没有数组就没有散列表。

Key，Value，散列函数，装载因子

## 散列冲突

1. 开放寻址法法，线性探测、二次探测(步长为 n 的二次方)、双重散列(多个散列函数)
2. 链表法

### 散列表碰撞攻击：

哈希表碰撞攻击就是通过精心构造数据，使得所有数据全部碰撞，人为将哈希表变成一个退化的单链表，此时哈希表各种操作的时间均提升了一个数量级，因此会消耗大量 CPU 资源，导致系统无法快速响应请求，从而达到拒绝服务攻击（DoS）的目的。

## 如何设计散列函数

散列函数设计的好坏，决定了散列表冲突的概率大小，也直接决定了散列表的性能

1. 散列表函数的设计不能太复杂
2. 散列函数生成的值要尽可能随机并且均匀分布

常用的方法：数据分析法、求余取模法、直接寻址法、平方取中法、折叠法、随机数法等

### 装载因子过大可使散列表支持动态扩容

当装载因子达到一个量时(如 0.8),使散列表容量扩大一倍则装载因子就会下降(0.4)。但动态扩容带来了数据迁移的问题，由于数组空间连续的，已保存的数据可能存在散列冲突问题，扩容后需要重新计算每个数据的存放位置。时间复杂度最好是 O1，最坏是 On，用摊还分析法均摊之后接近 O(1)

## 解决冲突的方法选择

1. 当数据量比较小、装载因子小的时候，适合采用开放寻址法
2. 基于链表的方法比较适合大对象、大数据量的散列表，而且，比起开放寻址法，更加灵活，支持更多的优化策略，比如用红黑树代替链表

### 工业级的散列表

- 支持快速的查询、插入、删除操作
- 内存占用合理，不能浪费过多的内容空间
- 性能稳定，极端环境下，散列表的性能也不会退化到无法接受的情况
