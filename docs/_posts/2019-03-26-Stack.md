---
title: "08. 栈"
---
## 栈
当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，就应该首选`栈`这种数据结构。

## 栈的实现
1. 顺序栈：用数组实现
2. 链式栈：用链表实现

## 使用单链表实现一个栈
```swift
    class Node<T> {
        var element: T
        var next: Node<T>?
        init(element: T, next: Node<T>? = nil) {
            self.element = element
            self.next = next
        }
    }
    class LinkStack<T> {
        var head: Node<T>?
        /// number of items in this stack
        private(set) var count: Int = 0
        
        func push(_ element: T) {
            let node = Node(element: element)
            node.next = head
            head = node
            count += 1
        }
        
        func pop() -> T? {
            guard let head = head else {
                return nil
            }
            self.head = head.next
            count -= 1
            return head.element
        }
    }
```

## 栈操作的时间、空间复杂度
- 入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是O(1)（注：说空间复杂度的时候，是指除了原本的数据存储空间外，算法所需的额外的存储空间）
- 出栈的时间复杂度是O(1)；链式栈的入栈是O(1)，顺序栈的入栈则受栈容量的影响，要考虑扩容时的消耗，最好情况O(1),最坏O(n)。均摊时间复杂度O(1)。

## 栈在表达式求值中的应用
加减乘除四则运算：30+2*4+10-12/4。对于这种四则运算，编译器是通过两个栈完成的。
- 其中一个栈保存操作数，另外一个保存运算符
- 当遇到数字时，直接压入操作数栈
- 当遇到运算符，就与运算符栈的栈顶元素进行比较：
    - 如果比运算符栈顶元素的优先级高，就将当前运算符压入操作符栈
    - 如果优先级低于或等于栈顶元素，则从操作数栈中取出两个操作数，然后进行计算，再把结算结果压入操作数栈

## 栈在括号匹配的应用
假设表达式中只包含3中括号`()`, `[]`, `{}`，它们可以任意嵌套。
- 用栈保存未匹配的左括号，从左到右依次扫描字符串
- 当扫描到左括号时，将其压栈
- 当扫描到右括号时，从栈顶取出一个左括号：
    - 如果匹配则继续扫描
    - 不匹配则说明非法格式
- 最后如果栈为空则验证通过，否则为非法格式

## 栈在浏览器前进后退功能中的应用
使用两个栈，X和Y
- 首次浏览的页面依次压入栈X，并清空Y
- 当点击后退按钮时，依次从栈X中出栈，并将出栈的数据压入栈Y中
- 当点击前进按钮时，依次从栈Y中出栈，并将出栈的数据压入栈X中
- 当栈X中没有数据时，则说明没有页面可以继续后退浏览了
- 当栈Y中没有数据时，则说明没有页面可以继续前进浏览了

## 思考
1. 为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？

    答：函数被调用时，变量的作用域发生变化，需要一个新的作用域来存放当前函数内的临时变量，并且当函数调用结束时，作用域被取消，函数执行点回到被调用处。而实现这个特性最方便的数据结构就是栈，当函数被调起时，分配一段栈空间给函数的局部变量，在函数结束时，将栈顶复位，回到调用函数的作用域。
2. 内存管理中有一个“堆栈“的概念，栈内存用来存储局部变量和方法调用，堆内存用来存储对象。那内存管理中的“栈”和数据结构所说的“栈”是不是一回事？如果不是，为什么它叫做“栈”呢？

    答：内存中的堆栈和数据结构的堆栈不是一回事，内存中的堆栈是映射到物理存储区的虚拟内存管理空间，而数据结构中的堆栈是抽象的数据存储结构。因为它们都有“先进后出“的特性，所以都叫“栈”。

    > 内存空间在逻辑上分为3部分：代码区、静态存储区和动态存储区，动态数据区又分为栈区和堆区。代码区存储函数体的二进制代码；静态存储区存储全局变量、常量；栈区存储运行方法的行参、局部变量、返回值。堆区存放新对象的真实数据，而对象的引用则在栈区内。( `let x = Foo()`Foo的本体数据在堆里，而x则在栈里)