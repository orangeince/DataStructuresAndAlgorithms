---
title: 05. 数组
---
# 数组

## 为什么数组的下标要从0开始呢？

A: 因为数组是线性表数据结构，使用下标随机寻址的公式为address = base + i * size，为了计算方便，所以下标要从0开始。下标确切的定义应该是“偏移“，a[n]就表示偏移n个size的位置。（有一些语言里的数组不是从0开始的，Matlab，而python的下标还能是负数）

## 纠错：链表适合插入、删除，时间复杂度O(1)；数组适合查找，查找时间复杂度O(1)。

这句话是错误的，就算是有序的数组使用二分查找法也得是O(logn)，所以正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。

## 数组低效的插入和删除操作

由于数组的空间是连续的，当需要忘数组中间插入值时，需要把当前位置以后的所有存储值做一个迁移操作，时间复杂度为O(n)。当删除一个值时，也需要把当前位置以后的值向前做一个位移操作，也是O(n)。不过在一些算法实践里对这种操作有优化，比如插入值时先把当前位置的值放到最后面(快排)。

## 数组越界导致C程序效果异常

```swift
    int main(int argc, char* argv[]){
        int i = 0;
        int arr[3] = {0};
        for(; i<=3; i++){
            arr[i] = 0;
            printf("hello world\n");
        }
        return 0;
    }
```

上面的代码并非是打印3行，而是无限打印“hello world”。因为数组大小3，判断条件i ≤ 3则会访问到a[3]的地址空间，由于c语言访问内存比较自由，a[3]指向的则正好是i的地址，因此会无限循环。

## 现代的一些高级语言对c的数组做了封装，比如Swift的Array，有数组越界检查，而且提供动态扩容的便利操作。

不过需要注意的一点是，动态扩容可能会是一个很耗资源的事情，因此在那些对性能要求高的场景下最好还是先给数组一个合适的初始大小。
