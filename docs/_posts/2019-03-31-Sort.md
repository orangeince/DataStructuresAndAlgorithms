---
title: 11. 排序（上）
---

# 排序

经典的排序算法：冒泡、插入、选择、归并、快速、计数、基数、桶

| 算法 | 时间复杂度 | 是否基于比较 |
| --- | --- | --- |
| 冒泡、插入、选择 | O(n^2) | 是 |
| 快排、归并 | O(nlogn) | 是 |
| 桶、基数、计数 | O(n) | 否 |

## 如何分析一个排序算法？

### 排序算法的执行效率

1. 最好情况、最坏情况、平均情况时间复杂度
2. 时间复杂度的系数、常数、低阶这些因素
3. 比较次数和交换(移动)次数

### 排序算法的内存消耗

算法内存的消耗可以通过空间复杂度来衡量。

原地排序(Sortied in place)，就是特指空间复杂度是O(1)的排序算法。

### 排序算法的稳定性

稳定性：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间的原有先后顺序不变。

## 冒泡排序

冒泡排序只会操作相邻的两个数据，每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让他俩交换，一次冒泡会让至少一个元素移动到它应该在的位置。

```swift
    func bubbleSort(_ elements: [Int]) -> [Int] {
        guard !elements.isEmpty else { return [] }
        var sorted = elements
        for i in 0 ..< sorted.count - 1 {
            for j in 1 ..< sorted.count - i {
                if sorted[j-1] > sorted[j] {
                    (sorted[j], sorted[j-1]) = (sorted[j-1], sorted[j])
                }
            }
        }
        return sorted
    }
```

- 冒泡排序是一个原地排序算法，冒泡的过程只涉及相邻数据的交换，只需要常量级的临时空间，所以空间复杂度为O(1)。
- 冒泡排序是稳定的，冒泡排序中，只有交换可以改变两个元素的前后顺序，为了保证稳定性，当相邻的两个元素相等时不做交换。
- 冒泡排序的时间复杂度是O(n^2)，最好时间复杂度是O(n)，最坏是O(n^2)，平均是O(n^2)。

    冒泡排序包含两个操作原子，比较和交换。每交换一次有序度加1，不管算法如何改进，交换次数总是确定的，即为逆序度，也就是n*(n-1)/2 - 初始有序度。所以平均情况下冒泡排序需要n*(n-1)/4次交换操作，比较操作肯定要比交换操作多，而复杂度上限是O(n^2)，所以使用“有序度”和“逆序度”的分析方法得出，平均复杂度为O(n^2)。

### 通过“有序度“和“逆序度”分析时间复杂度

- 有序度是数组中具有有序关系的元素对的个数。有序元素对：a[i] ≤ a[j], 其中i < j。比如数组6，5，4，3，2，1，有序度是0；而1，2，3，4，5，6的有序度是 n*(n-1)/2，也就是15，这种完全有序的数组的有序度叫做“满有序度”
- 逆序度的定义正好相反，逆序元素对：a[i] > a[j], 其中i < j。
- 逆序度 = 满有序度 - 有序度
- 排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度。

## 插入排序

把数组中的数据分为两个区间，已排序区间和未排序区间。取未排序区间的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复直到未排序区间中元素为空

```swift
    func insertionSort(_ elements: [Int]) -> [Int] {
        guard !elements.isEmpty else { return [] }
        var sorted = elements
        for i in 1 ..< sorted.count {
            for j in 0 ... i - 1 {
                if sorted[i] < sorted[j] {
                    let n = sorted.remove(at: i)
                    sorted.insert(n, at: j)
                }
            }
        }
        return sorted
    }
```

- 插入排序是原地排序算法，运行时不需要额外的存储空间，空间复杂度是O(1)。
- 插入排序是稳定的排序算法。
- 插入排序的时间复杂度，最好情况是O(n)，最坏情况是O(n^2)，在数组中插入一个数据的时间复杂度是O(n)，所以插入排序的平均时间复杂度是O(n^2)。

## 选择排序

选择排序算法的实现思路和插入排序类似，也分已排序区间和未排序区间，但选择排序每次会从为排序区间中找到最小的元素，将其放入已排序区间的末尾。

```swift
    func selectionSort(_ elements: [Int]) -> [Int] {
        guard !elements.isEmpty else { return [] }
        var sorted = elements
        for i in 0 ..< sorted.count - 1 {
            var min = i
            for j in i+1 ..< sorted.count {
                if sorted[j] < sorted[min] {
                    min = j
                }
            }
            if i != min {
                (sorted[min], sorted[i]) = (sorted[i], sorted[min])
            }
        }
        return sorted
    }
```

- 选择排序也是原地排序算法
- 选择排序不是稳定的排序，选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。比如553，第一个5会被替换到3的位置。
- 选择排序的时间复杂度最好、最坏、平均情况都为O(n^2)

## 冒泡排序和插入排序的时间复杂度都为O(n^2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？

冒泡排序和插入排序的元素交换次数都是固定的，都是原数据的逆序度。

但是，从代码的实现上看，冒泡排序的数据交换要比插入排序的数据移动复杂，冒泡排序需要3个赋值操作(非swift的实现，需要借助一个临时变量)，而插入排序只需要1个。

```c
    // 冒泡排序中数据的交换操作：
    if (a[j] > a[j+1]) { // 交换
       int tmp = a[j];
       a[j] = a[j+1];
       a[j+1] = tmp;
       flag = true;
    }
    
    // 插入排序中数据的移动操作：
    if (a[j] > value) {
      a[j+1] = a[j];  // 数据移动
    } else {
      break;
    }
```

把执行一个赋值语句的时间粗略地计为单位时间，然后分别用冒泡排序和插入排序对同一个逆序度的K数组进行排序。冒泡需要K次交换操作，每次需要3个赋值语句，所以交换操作总耗时为3*K单位时间，而插入排序中数据移动操作只需要K个单位时间。

- 对插入排序的优化感兴趣的话，可以看一看[希尔排序]([https://zh.wikipedia.org/wiki/希尔排序](https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F))

### 课后思考题

以上实现的排序算法都是基于数组的，如果换成链表来存储数据，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？

答：可以用链表实现，复杂度没啥变化。