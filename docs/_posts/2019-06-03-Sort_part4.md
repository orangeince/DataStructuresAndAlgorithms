---
title: 14. 排序优化
---

## 如何实现一个通用的、高性能的排序算法

### 如何选择合适的排序算法？

| 名称 | 时间复杂度 | 是否稳定排序 | 是否原地排序 |
| --- | --- | --- | --- |
| 冒泡排序 | O(n^2) | 是 | 是 |
| 插入排序 | O(n^2) | 是 | 是 |
| 选择排序 | O(n^2) | 否 | 是 |
| 快速排序 | O(nlogn) | 否 | 是 |
| 归并排序 | O(nlogn) | 是 | 否 |
| 计数排序 | O(n+k) k是数据范围 | 是 | 否 |
| 桶排序 | O(n) | 是 | 否 |
| 基数排序 | O(dn) d是维度 | 是 | 否 |

- 小规模数据排序，可以选择时间复杂度是O(n^2)的算法
- 大规模数据排序，时间复杂度是O(nlogn)的算法更高效
- 为了兼顾任意规模数据的排序，一般都会首选O(nlogn)的排序算法实现

### 如何优化快速排序

快速排序的时间复杂度会退化到O(n^2)，出现的主要原因是分区点选的不合理

最理想的分区点是：被分开的两个分区中，数据

1. 三数取中法，从区间的首、尾、中间，分别取出一个数，对比大小，取中间值作为分区点
2. 随机法，每次随机算择一个元素作为分区点，从概率的角度来看会好一些

快速排序还要考虑，递归的实现可能导致堆栈溢出。（1限制递归深度，2模拟函数调用栈）

### 一些零碎点

- 数据量不是特别大时可以考虑牺牲空间，使用归并排序，而数据量很大时用快速排序
- O(n^2)的算法并不一定比O(nlogn)的算法执行时间长（时间复杂度代表的是一个增长趋势，大O复杂度表示法会忽略低阶、系数和常数，knlogn+c在小规模数据下可能远大于n^2）
- 虽然哨兵可能只是减少了一次判断，但毕竟函数是非常常用和基础的函数，性能优化要做到极致

### 思考题

分析一下你所熟悉的语言中排序函数，是用的什么算法实现？

答：Swift的[排序算法实现](https://github.com/apple/swift/blob/master/stdlib/public/core/Sort.swift)使用的是改良版的归并排序，和Python一致的[Timsort](https://en.wikipedia.org/wiki/Timsort)算法。工业级的改良版本归并排序。