## 线性排序算法

时间复杂度是线性的O(n)。包括：桶排序、计数排序、基数排序。

> 之所以能做到线性的时间复杂度，主要原因是这三个算法是非基于比较的排序算法，都不涉及元素之间的比较操作。因此对数据也有一定的要求，有相应的适用场景。

## 桶排序(Bucket sort)

将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序，桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

桶排序的时间复杂度是`(接近)`O(n)：排序数据有n个，均匀的划分到m个桶里，每个桶有k=n/m个元素。每个桶使用快速排序，时间复杂度为O(k*logk)，m个桶排序的时间复杂度就是O(m*k*logk),即桶排序的时间复杂度为O(n*log(n/m)),当桶的个数接近数据个数n时，log(n/m)就是一个非常小的常量，这个时候桶排序的时间复杂度接近O(n)

- 桶排序对数据的要求比较苛刻，要分为m个桶，桶之间要有天然的大小顺序，桶的分配需要是均匀的，如果不能均分的话，极端情况下，全部都分到一个桶则就退化为O(nlogn)。
- 桶排序比较适合外部排序：数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。
- 桶排序的最关键要素就是数据的分布，是否能均匀的分配，或者是合理的分配。

## 计数排序(Counting sort)

计数排序很像是桶排序的一种特殊情况。当要排序的N个数据，所处的范围并不大的时候，比如最大值是k，我们就可以把数据划分为k个桶，每个桶内的数据值都是相同的，省掉了桶内排序的时间

```swift
    func countingSort(_ origin: [Int]) -> [Int] {
        guard origin.count > 0 else {
            return origin
        }
        
        // 确定数组中数据的范围
        var max = origin[0]
        for n in origin {
            if n > max {
                max = n
            }
        }
        
        var countingArr = Array<Int>(repeating: 0, count: max + 1)
        // 计算每个元素的个数，放入countingArr
        for i in 0..<origin.count {
            countingArr[origin[i]] += 1
        }
        
        // 依次累加
        for i in 1...max {
            countingArr[i] = countingArr[i - 1] + countingArr[i]
        }
        
        // 临时数组r，存储排序之后的结果
        var r = Array<Int>(repeating: 0, count: origin.count)
        // 计数排序的关键步骤
        for i in (0..<r.count).reversed() {
            let idx = countingArr[origin[i]] - 1
            r[idx] = origin[i]
            countingArr[origin[i]] -= 1
        }
        return r
    }
```

计数排序只能用在数据范围不大的场景中，如果数据范围k比要排序的数据n大很多，就不适合用计数排序了，而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。

## 基数排序(Radix sort)

假设有10w个手机号，从下到大排序这些数据，可以使用基数排序

先按照最后一位来排序手机号，然后再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序，经过11次排序之后，手机号码就有序了。

每一位的排序使用桶排序或计数排序，时间复杂度就可以做到O(n),如果k位，那需要k次的桶排序或计数排序，总的时间复杂度是O(k*n)，当k不大时，时间复杂度近似O(n)

> 基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果a数据的高位比b数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到O(n)了。